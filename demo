import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
import tkinter as tk
from tkinter import filedialog
import os

# --- CONFIGURATION ---
MODEL_PATH = 'ball_classification.h5'
IMG_SIZE = (192, 192)   # The size your model expects (input_shape)
DETECTION_WIDTH = 1024  # Size used ONLY for finding the circle (speeds up scanning)

CLASS_LABELS = [
    'basketball', 
    'billiard_ball', 
    'bowling_ball', 
    'football', 
    'tennis_ball', 
    'volleyball'
]

def select_image():
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.askopenfilename(
        title="Select an Image",
        filetypes=[("Image Files", "*.jpg *.jpeg *.png *.bmp *.webp")]
    )
    root.destroy()
    return file_path

def preprocess_for_model(roi, target_size):
    roi = cv2.resize(roi, target_size)
    roi = roi.astype('float32') / 255.0
    roi = np.expand_dims(roi, axis=0)
    return roi

def main():
    if not os.path.exists(MODEL_PATH):
        print(f"Error: Model file '{MODEL_PATH}' not found.")
        return

    try:
        model = load_model(MODEL_PATH)
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    image_path = select_image()
    if not image_path: return
    
    # 1. Load Original Image (High Resolution)
    original_image = cv2.imread(image_path)
    if original_image is None: return
    
    orig_h, orig_w = original_image.shape[:2]
    
    # 2. Resize ONLY for detection scanning (to make it fast)
    scale_ratio = DETECTION_WIDTH / float(orig_w)
    new_height = int(orig_h * scale_ratio)
    resized_image = cv2.resize(original_image, (DETECTION_WIDTH, new_height), interpolation=cv2.INTER_AREA)
    
    gray = cv2.cvtColor(resized_image, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (9, 9), 2)

    # 3. Detect Balls
    circles = cv2.HoughCircles(
        gray, 
        cv2.HOUGH_GRADIENT, 
        dp=1.2, 
        minDist=50,       
        param1=50,        
        param2=30,        
        minRadius=20,     
        maxRadius=400
    )

    final_output = original_image.copy()
    ball_found = False

    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        print(f"Found {len(circles)} object(s). Scaling to original size...")
        
        for (x_small, y_small, r_small) in circles:
            # --- STEP A: Scale coordinates back to ORIGINAL size ---
            # We divide by scale_ratio to get the real pixel locations
            x_real = int(x_small / scale_ratio)
            y_real = int(y_small / scale_ratio)
            r_real = int(r_small / scale_ratio)
            
            # --- STEP B: Dynamic Padding ---
            # Instead of fixed pixels, we take 25% of the radius as padding.
            # This ensures the box fits the ball perfectly regardless of image size.
            padding = int(r_real * 0.25)
            
            y_min = max(0, y_real - r_real - padding)
            y_max = min(orig_h, y_real + r_real + padding)
            x_min = max(0, x_real - r_real - padding)
            x_max = min(orig_w, x_real + r_real + padding)

            # Crop the FULL RESOLUTION ball
            roi = original_image[y_min:y_max, x_min:x_max]
            
            # Skip if crop is invalid
            if roi.size == 0 or roi.shape[0] == 0 or roi.shape[1] == 0:
                continue

            # 4. Predict
            processed_roi = preprocess_for_model(roi, IMG_SIZE)
            predictions = model.predict(processed_roi, verbose=0)
            
            class_idx = np.argmax(predictions[0])
            confidence = predictions[0][class_idx]
            label = CLASS_LABELS[class_idx]

            if confidence > 0.4:
                ball_found = True
                
                # --- STEP C: Dynamic Drawing Thickness ---
                # Calculate line thickness based on image size so it's visible on 4K images
                line_thickness = max(3, int(orig_w / 300))
                font_scale = max(0.8, orig_w / 1000.0)
                
                # Draw Box on Original Image
                cv2.rectangle(final_output, (x_min, y_min), (x_max, y_max), (0, 255, 0), line_thickness)
                
                # Draw Label
                label_text = f"{label}: {confidence*100:.1f}%"
                (w, h), _ = cv2.getTextSize(label_text, cv2.FONT_HERSHEY_SIMPLEX, font_scale, line_thickness)
                
                # Label Background
                cv2.rectangle(final_output, (x_min, y_min - int(h*1.5)), (x_min + w, y_min), (0, 255, 0), -1)
                
                # Label Text
                cv2.putText(final_output, label_text, (x_min, y_min - int(h*0.3)),
                            cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 0, 0), line_thickness)
                
                print(f"Detected: {label} (Size: {x_max-x_min}x{y_max-y_min}px)")

    # 5. Display Logic (Handle huge images for viewing)
    if ball_found:
        print("Displaying result...")
        # If image is too tall for screen (e.g. > 900px), shrink the VIEW only
        screen_h_limit = 900
        if final_output.shape[0] > screen_h_limit:
            scale_view = screen_h_limit / final_output.shape[0]
            new_w = int(final_output.shape[1] * scale_view)
            new_h = int(final_output.shape[0] * scale_view)
            view_img = cv2.resize(final_output, (new_w, new_h))
            cv2.imshow("Result (Scaled to fit screen)", view_img)
        else:
            cv2.imshow("Result (Original)", final_output)
            
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    else:
        print("No balls detected.")

if __name__ == "__main__":
    main()
