import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
import tkinter as tk
from tkinter import filedialog
import os

# --- CONFIGURATION ---
MODEL_PATH = 'ball_classification.h5'
# IMG_SIZE is now removed. We will read it from the model automatically.

CLASS_LABELS = [
    'basketball', 
    'billiard_ball', 
    'bowling_ball', 
    'football', 
    'tennis_ball', 
    'volleyball'
]

def select_image():
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.askopenfilename(
        title="Select an Image",
        filetypes=[("Image Files", "*.jpg *.jpeg *.png *.bmp *.webp")]
    )
    root.destroy()
    return file_path

def preprocess_for_model(roi, target_size):
    """
    Resize the crop to match the model's expected input size.
    """
    roi = cv2.resize(roi, target_size)
    roi = roi.astype('float32') / 255.0
    roi = np.expand_dims(roi, axis=0)
    return roi

def main():
    # 1. Load Model
    if not os.path.exists(MODEL_PATH):
        print(f"Error: Model file '{MODEL_PATH}' not found.")
        return

    try:
        print(f"Loading model from {MODEL_PATH}...")
        model = load_model(MODEL_PATH)
        
        # --- NEW: Auto-detect Input Size ---
        # model.input_shape usually looks like (None, Height, Width, Channels)
        # We grab the Height and Width (index 1 and 2)
        input_shape = model.input_shape[1:3]
        print(f"Model loaded. It expects input size: {input_shape}")
        
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    # 2. Select Image
    image_path = select_image()
    if not image_path: return
    
    # Load image at ORIGINAL size
    original_image = cv2.imread(image_path)
    if original_image is None: return
    
    orig_h, orig_w = original_image.shape[:2]
    
    # 3. Preprocess for Detection
    gray = cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (9, 9), 2)

    # 4. Detect Balls
    circles = cv2.HoughCircles(
        gray, 
        cv2.HOUGH_GRADIENT, 
        dp=1.2, 
        minDist=50,       
        param1=50,        
        param2=30,        
        minRadius=10,     
        maxRadius=int(min(orig_h, orig_w) / 1.5)
    )

    output_image = original_image.copy()

    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        print(f"Found {len(circles)} object(s). Processing...")
        
        for (x, y, r) in circles:
            padding = int(r * 0.25)
            
            y_min = max(0, y - r - padding)
            y_max = min(orig_h, y + r + padding)
            x_min = max(0, x - r - padding)
            x_max = min(orig_w, x + r + padding)

            roi = original_image[y_min:y_max, x_min:x_max]
            
            if roi.size == 0: continue

            # --- USE AUTO-DETECTED SIZE HERE ---
            processed_roi = preprocess_for_model(roi, input_shape)
            predictions = model.predict(processed_roi, verbose=0)
            
            class_idx = np.argmax(predictions[0])
            confidence = predictions[0][class_idx]
            label = CLASS_LABELS[class_idx]

            if confidence > 0.4:
                line_thickness = max(3, int(orig_w / 300))
                font_scale = max(0.8, orig_w / 1000.0)
                
                # Draw Box
                cv2.rectangle(output_image, (x_min, y_min), (x_max, y_max), (0, 255, 0), line_thickness)
                
                # Draw Label
                label_text = f"{label}: {confidence*100:.1f}%"
                (w, h), _ = cv2.getTextSize(label_text, cv2.FONT_HERSHEY_SIMPLEX, font_scale, line_thickness)
                
                cv2.rectangle(output_image, (x_min, y_min - int(h*1.5)), (x_min + w, y_min), (0, 255, 0), -1)
                cv2.putText(output_image, label_text, (x_min, y_min - int(h*0.3)),
                            cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 0, 0), line_thickness)
                
                print(f"Detected: {label}")

    # 5. Display Result
    screen_h_limit = 900
    if output_image.shape[0] > screen_h_limit:
        scale_view = screen_h_limit / output_image.shape[0]
        new_w = int(output_image.shape[1] * scale_view)
        new_h = int(output_image.shape[0] * scale_view)
        view_img = cv2.resize(output_image, (new_w, new_h))
        cv2.imshow("Ball Classification", view_img)
    else:
        cv2.imshow("Ball Classification", output_image)
            
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
