import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
import tkinter as tk
from tkinter import filedialog
import os

# --- CONFIGURATION ---
MODEL_PATH = 'ball_classification.h5'
IMG_SIZE = (224, 224) 

# Your specific classes
CLASS_LABELS = [
    'basketball', 
    'billiard_ball', 
    'bowling_ball', 
    'football', 
    'tennis_ball', 
    'volleyball'
]

def select_image():
    """
    Opens a file dialog to let the user select an image.
    Returns the file path or None if cancelled.
    """
    # Create a hidden root window (we don't need a full GUI, just the popup)
    root = tk.Tk()
    root.withdraw() 
    
    print("Opening file selector...")
    file_path = filedialog.askopenfilename(
        title="Select an Image of a Ball",
        filetypes=[("Image Files", "*.jpg *.jpeg *.png *.bmp *.webp")]
    )
    
    # Destroy the root window after selection
    root.destroy()
    return file_path

def preprocess_for_model(roi, target_size):
    # Resize to the input shape the model expects
    roi = cv2.resize(roi, target_size)
    # Normalize (0-1)
    roi = roi.astype('float32') / 255.0
    # Add batch dimension
    roi = np.expand_dims(roi, axis=0)
    return roi

def main():
    # 1. Load the trained model
    if not os.path.exists(MODEL_PATH):
        print(f"Error: Model file '{MODEL_PATH}' not found in this folder.")
        return

    try:
        print(f"Loading model from {MODEL_PATH}...")
        model = load_model(MODEL_PATH)
        print("Model loaded successfully.")
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    # 2. Select the image using the file dialog
    image_path = select_image()
    
    if not image_path:
        print("No image selected. Exiting.")
        return
        
    print(f"Processing image: {image_path}")
    image = cv2.imread(image_path)
    
    if image is None:
        print(f"Error: Could not read image.")
        return
    
    output_image = image.copy()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # 3. Detect Balls (Hough Circle Transform)
    # Note: Adjust param2 down (e.g., to 20 or 25) if it misses balls.
    circles = cv2.HoughCircles(
        gray, 
        cv2.HOUGH_GRADIENT, 
        dp=1.2, 
        minDist=50,       
        param1=50,        
        param2=30,        
        minRadius=10, 
        maxRadius=400
    )

    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        print(f"Found {len(circles)} potential object(s). Classifying...")

        for (x, y, r) in circles:
            # 4. Extract ROI
            padding = 10 
            y_min = max(0, y - r - padding)
            y_max = min(image.shape[0], y + r + padding)
            x_min = max(0, x - r - padding)
            x_max = min(image.shape[1], x + r + padding)

            roi = image[y_min:y_max, x_min:x_max]
            if roi.size == 0: continue

            # 5. Predict
            processed_roi = preprocess_for_model(roi, IMG_SIZE)
            predictions = model.predict(processed_roi, verbose=0)
            
            class_idx = np.argmax(predictions[0])
            confidence = predictions[0][class_idx]
            label = CLASS_LABELS[class_idx]

            # 6. Draw results if confidence is decent (> 40%)
            if confidence > 0.4:
                # Green box
                cv2.rectangle(output_image, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
                
                # Label
                label_text = f"{label}: {confidence*100:.1f}%"
                (w, h), _ = cv2.getTextSize(label_text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
                cv2.rectangle(output_image, (x_min, y_min - 20), (x_min + w, y_min), (0, 255, 0), -1)
                cv2.putText(output_image, label_text, (x_min, y_min - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
                
                print(f"Detected: {label} with {confidence*100:.1f}% confidence")

        # Show result
        cv2.imshow("Ball Classification", output_image)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    else:
        print("No circular objects detected in this image.")

if __name__ == "__main__":
    main()
